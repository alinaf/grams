<!DOCTYPE html>
<html>
<head>
  <!-- basic script -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser.js"></script>
</head>
<body>

  <script>
    const brightBlue = "#459ac4";
    var currentWord = "";
    var wordStrings = [];
    var letterMap = new Map();
    var currentSquares = [];

    // demo 1: rat + star + cake
    // demo 2: rat + star + rackets
    var letterBag = ["r", "t", "a", "s", "k", "a", "e", "c"];
    var pos = 0; // no queue in JS apparently so just use this

    var validWords = new Set(["rat", "art", "tar", "star", "rackets", "cake", "cakes"]);
    var plurals = new Set(["rats"]); // doesn't actually work because each word needs its own memory
    // put "s" in (hacky), lots of complexities i'm skimming over

    var currHeight = 300;
    var left = true;

    var config = {
      type: Phaser.WEBGL,
      width: 1400,
      height: 750,
      backgroundColor: "#d3e8e8",

      scene: {
        preload: preload,
        create: create,
        // update: update,
      }
    };

    var context;

    var game = new Phaser.Game(config);
    var squares = [];
    var textBoxes = [];
    var currentWordText;
    var camera;
    var score = 0;
    var scoreText;
    //var rankText;

    // var bonus;
    // var bankHeight = 50;
    // var bankWidth = 670;
    // var bank;
    // var highlight;

    function preload ()
    {
    this.load.image('square', 'assets/square.png');
    this.load.image('submit', 'assets/submit.png');
    this.load.audio('music', 'assets/whatsleft.mp3');
   }

   function create ()
   {
    context = this;
    camera = this.cameras.main;
    currentWordText = this.add.text(700, 650, "", { font: "70px Karla", fill: '#000000' });
    currentWordText.setOrigin(0.5);
    scoreText = this.add.text(700, 700, "score: 0", { font: "25px Karla", fill: '#000000'});
    const music = this.sound.add('music');
    music.setLoop(true);
    music.play();

    this.input.keyboard.on('keydown_ENTER', submitWord);
    this.input.keyboard.on('keydown_BACKSPACE', deleteLetter);



    // might add
    //rankText = this.add.text(250, 590, "rank: beginner", { font: "25px Karla", fill: '#000000'});
   // rankString = "beginner・good start・solid\n nice・great・amazing・genius";
   // var ranks = this.add.text(250, 635, rankString, { font: "18px Karla", fill: '#000000'});

    // make grid
    var width = 0;
    for(i = 0; i < 9; i++){
        width += 90;
      
      const square = this.add.sprite(width, 100, 'square');
      square.tint = 0x459ac4;

      text = this.add.text(square.x - 18, square.y - 33, letterBag[i], { font: "60px Karla", fill: '#FFFFFF' });

      textBoxes.push(text);
      square.setInteractive();
      text.visible = false;
      square.visible = false;
      letterMap.set(square, letterBag[i]);
      square.on('pointerover', function(pointer) {
        this.setTint(0x054f4a);
      });
      square.on('pointerout', function(pointer) {
        this.setTint(0x459ac4);
      });
      square.on('pointerup', function(pointer) {
        updateString(this, letterMap.get(this));
      });

      squares.push(square);
    }
    drawTile();
    drawTile();
    drawTile();
    drawTile();

  }

  async function submitWord() {
    if(currentWord.length < 3) return;
          console.log(currentWord);

    const errorMessage = validWord(currentWord);
    if(errorMessage != "") {
      camera.shake(700, 0.003);
      currentSquares = [];
      currentWordText.setText(errorMessage);
      await sleep(1000);
      currentWord = "";
      currentWordText.setText(currentWord);
      return;
    }
    addWord(context, currentWord);
    currentWord = "";
    currentWordText.setText(currentWord);
    currentSquares = [];
}

function validWord(currentWord) {
  if(plurals.has(currentWord)) {
    console.log("has");
    return "no plurals!";
  }
  return "";
}

  function deleteLetter() {
    if(!currentWord.length) return;
    currentWord = currentWord.slice(0, -1);
    currentWordText.setText(currentWord);
    console.log(currentSquares);
    currentSquares.pop();
    console.log(currentSquares);
}

  function updateString(square, letter) {
    if(currentSquares.includes(square)) {
      camera.shake(500, 0.003);
      return;
    }
    currentSquares.push(square);
    currentWord += letter;
    currentWordText.setText(currentWord);
    // only use one letter once
    // only use letters from one word or center tiles
  }



  function drawTile() {
    squares[pos].visible = true;
    textBoxes[pos].visible = true;
    pos++;
    // oof rearranging will be tough
  }

  function addWord(context, word) {
    var width = left? 0 : 750;
    left = !left;
    for(i = 0; i < word.length; i++){
        width += 90;
      
      const square = context.add.sprite(width, currHeight, 'square');
      square.tint = 0x459ac4;
        square.on('pointerover', function(pointer) {
        this.setTint(0x054f4a);
      });
      square.on('pointerout', function(pointer) {
        this.setTint(0x459ac4);
      });
      square.on('pointerup', function(pointer) {
        console.log("click");
      });


      text = context.add.text(square.x - 18, square.y - 33, word[i], { font: "60px Karla", fill: '#FFFFFF' });

      // textBoxes.push(text);
       square.setInteractive();
      // squares.push(square);
    }
    if(left) currHeight += 120; // every other time
  }
    // avert ur eyes, so dumb but i'm in a rush, will fix later
    // loop doesn't work because it looks up last value of i when it calls the function
  //   squares[0].on('pointerup', function() {
  //     enterLetter(0);
  //   });
  //   squares[1].on('pointerup', function() {
  //     enterLetter(1);
  //   });
  //   squares[2].on('pointerup', function() {
  //     enterLetter(2);
  //   });
  //   squares[3].on('pointerup', function() {
  //     enterLetter(3);
  //   });
  //   squares[4].on('pointerup', function() {
  //     enterLetter(4);
  //   });
  //   squares[5].on('pointerup', function() {
  //     enterLetter(5);
  //   });
  //   squares[6].on('pointerup', function() {
  //     enterLetter(6);
  //   });
  //   squares[7].on('pointerup', function() {
  //     enterLetter(7);
  //   });
  //   squares[8].on('pointerup', function() {
  //     enterLetter(8);
  //   });
  // }

  // function enterLetter(i) {
  //   if(i == 7) {
  //     back();
  //   }
  //   else if (i == 8) {
  //     shuffle();
  //   }
  //   else {
  //     addLetter(letters[i]);
  //   }
  // }

  // function back() {
  //   string = string.slice(0, -1);
  //   currentWord.setText(string);
  // }

  // function shuffle() {
  //   Phaser.Utils.Array.Shuffle(freeLetters);
  //   // what a mess
  //   for(i = 0; i < 4; i++) {
  //     letters[i] = freeLetters[i];
  //   }
  //   for(i = 5; i < 7; i++) {
  //     letters[i] = freeLetters[i-1]
  //   }
  //   for(i = 0; i < textBoxes.length; i++) {
  //     textBoxes[i].setText(letters[i]);
  //   }
  // }

  // function addLetter(letter) {
  //   string += letter;
  //   currentWord.setText(string);
  // }


  // async function check ()
  // {
  //   var bad = false;
  //   var message = "";
  //   if(string.length <= 3) {
  //     message = "too short";
  //     bad = true;
  //   }

  //   else if(!string.includes(letters[4])) {
  //     message = "missing " + "'" + letters[4] + "'";
  //     bad = true;
  //   }

  //   else if (!words.has(string)) {
  //     message = "invalid word";
  //     bad = true;
  //   }

  //   else if (submitted.has(string)) {
  //     message = "already used";
  //     bad = true;
  //   }

  //   if (bad) {
  //     currentWord.setText(message);
  //     camera.shake(1000, 0.003);
  //     await sleep(1000);
  //     currentWord.setText(string);
  //     return;
  //   }
  //   else {
  //     submitted.add(string);
  //     currentWord.fill = '0xF5C50B';
  //     var bonusScore = calculateBonus(string);
  //     if(isPangram(string)) {
  //       bonusScore += 7;
  //       bonus.setText("Pangram! +" + bonusScore + "!");

  //     }
  //     else {
  //       bonus.setText("+" + bonusScore + "!");
  //     }
  //     bonus.visible = true;
  //     score += bonusScore;
  //     scoreText.setText("score: " + score);
  //     var rank = calculateRank();
  //     rankText.setText("rank: " + rank);
  //     await sleep(600);
  //     bonus.visible = false;
  //     wordBankwords += ("\n" + string);
  //     bank.setText(wordBankwords);
  //     string = "";
  //     currentWord.setText(string);
  //   }
  // }

  // function calculateRank() {
  //   // total possible = 156
  //   if(score < 2) {
  //     highlight.x = 285;
  //     highlight.y = 648;
  //     return "beginner";
  //   }
  //    if(score < 15) {
  //     highlight.x = 380;
  //     highlight.y = 648;
  //     return "good start";
  //   }
  //    if(score < 20) {
  //     highlight.x = 465;
  //     highlight.y = 648;
  //     return "solid";
  //   }
  //    if(score < 33) {
  //     highlight.x = 275;
  //     highlight.y = 668;
  //     return "nice";
  //   }
  //    if(score < 40) {
  //     highlight.x = 325;
  //     highlight.y = 668;
  //     return "great";
  //   }
  //    if(score < 55) {
  //     highlight.x = 400;
  //     highlight.y = 668;
  //     return "amazing";
  //   }
  //    if(score < 78) {
  //     highlight.x = 485;
  //     highlight.y = 668;
  //     return "genius";
  //   }
  // }

  // function calculateBonus(word) {
  //   if(word.length == 4) {
  //     return 1;
  //   }

  //   return word.length;
  // }

  // function isPangram(word) {
  //   for(i = 0; i < letters.length - 2; i++) {
  //     if(!word.includes(letters[i])) {
  //       return false;
  //     }
  //   }
  //   return true;
  // }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

       // function update() {
        //console.log('hi');
      //   if (!gameState.active) {
      //    if (gameState.cursors.space.isDown) {
      //      gameState.score = 0;
      //      gameState.active = true;
      //      this.scene.restart();
      //    }
      //  }


      //  if (gameState.cursors.left.isDown) {
      //   gameState.player.setVelocityX(gameState.playerVelocity * -1);
      // } else if (gameState.cursors.right.isDown) {
      //   gameState.player.setVelocityX(gameState.playerVelocity);
      // } 
      // else {
      //   gameState.player.setVelocityX(0);
      // }
    // }



</script>

</body>
</html>